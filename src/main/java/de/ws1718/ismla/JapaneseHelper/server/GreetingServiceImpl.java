package de.ws1718.ismla.JapaneseHelper.server;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

import com.google.gwt.user.server.rpc.RemoteServiceServlet;

import de.ws1718.ismla.JapaneseHelper.client.GreetingService;
import de.ws1718.ismla.JapaneseHelper.shared.InflectedToken;
import de.ws1718.ismla.JapaneseHelper.shared.Token;

/**
 * The server side implementation of the RPC service.
 */
@SuppressWarnings("serial")
public class GreetingServiceImpl extends RemoteServiceServlet implements GreetingService {
	private static final Logger logger = Logger.getLogger(GreetingServiceImpl.class.getSimpleName());

	// requires the file inside the directory to have been generated by
	// WiktionaryPreprocessor
	private static final String DICTIONARY_GENERATED_PATH = "/WEB-INF/dictionary-full";
	private Set<Token> tokens;

	public String greetServer(String input) throws IllegalArgumentException {
		readTokens();
		return "done";
	}

	private void readTokens() {
		tokens = new HashSet<>();
		String line;
		List<String> dictFileList = new ArrayList<String>(
				getServletContext().getResourcePaths(DICTIONARY_GENERATED_PATH));
		// size == 1
		String dictFile = dictFileList.get(0);
		try (InputStream stream = getServletContext().getResourceAsStream(dictFile);
				BufferedReader br = new BufferedReader(new InputStreamReader(stream, "UTF-8"))) {
			while ((line = br.readLine()) != null) {
				line = line.trim();
				if (line.startsWith("ï»¿##") || line.startsWith("##")) {
					// the first version contains control characters
					continue;
				}
				String[] fields = line.split("\t");

				Token tok = null;
				if (fields.length == 4) {
					tok = new Token(fields[0], fields[1], fields[2], fields[3]);
				} else if (fields.length == 6) {
					tok = new InflectedToken(fields[0], fields[1], fields[2], fields[3], fields[4], fields[5]);
				} else {
					continue;
				}
				logger.info(tok.toString());
				tokens.add(tok);
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		logger.info("read tokens");
	}

	// Only for use in tester classes.
	public ArrayList<String> processGlossesTester(String glosses) {
		return processGlosses(glosses);
	}

	private ArrayList<String> processGlosses(String glosses) {
		ArrayList<String> results = new ArrayList<>();
		// The position of the last index digit, e.g. '1' in "1) "
		int lastIndexPos = -1;
		String lastGloss = "";

		for (int curPointer = 0; curPointer < glosses.length(); curPointer++) {
			if (curPointer + 1 != glosses.length()) {
				// Match an index term, e.g. 1)
				if (Character.isDigit(glosses.charAt(curPointer)) && glosses.charAt(curPointer + 1) == ')') {
					// If it's not the first gloss, we should have already recorded something previously
					if (glosses.charAt(curPointer) != '1') {
						lastGloss = glosses.substring(lastIndexPos + 3, curPointer - 1);
					}
					// Record the index position. This also works if it's the first gloss.:w
					lastIndexPos = curPointer;
				}
			} else { // We've come to the end of the whole glosses string and we should record the last entry anyways.
				// There is no extra space to deal with now. Need to stretch it to the end.
				lastGloss = glosses.substring(lastIndexPos + 3, curPointer + 1);
			}

			// If we already got a gloss at the end of this step, we add it.
			if (!lastGloss.isEmpty()) {
				// A lot of entries are "?". We don't want to add such entries.
				if (!lastGloss.equals("?")) {
					results.add(lastGloss);
				}
				lastGloss = "";
			}
		}
		return results;
	}
}
